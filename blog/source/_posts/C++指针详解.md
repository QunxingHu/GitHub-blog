---
title: C++指针详解
date: 2016-08-28 23:46:36
categories:
	- 术业专攻
tags: 
	- C++
---
本文总结了C++指针的相关概念、以及一些指针的基本操作。除此之外对多级指针，指针数组，指针与引用等比较容易混淆的概念，对智能指针等也进行了总结。
<!-- more -->
## 什么是指针？
指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。
**定义：** `type * var_name;`
**type:**  为指针的基类型（即为所指向数据的类型）。
不管指针所指向的数据类型是什么数据类型，指针的值的数据类型都是一个代表内存地址的**长的十六进制数**。
**基本使用：**
1. 定义一个变量
2. 定义一个指针变量
3. 将变量的地址赋值给指针
4. 访问指针变量中所指向的内存地址的值
```cpp?linenums
int var = 20
int *ip;
ip = &var;
cout << *ip << endl;
```
## 空指针（NULL指针）
在变量声明的时候，**如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯**。赋为 NULL 值的指针被称为空指针。如：`int  *ptr = NULL;`
在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。
如需**检查一个空指针**，您可以使用 if 语句，如下所示：
```cpp?linenums
if(ptr){  
	/* 如果 p 非空，则完成 */
	cout << *ptr;
}
else{
	cout << "ptr is NULL";
}
```
因此，如果所有未使用的指针都被赋予空值，同时避免使用空指针，就可以防止误用一个未初始化的指针。很多时候，未初始化的变量存有一些垃圾值，导致程序难以调试

## 指针的运算
指针的算术运算类型：（++，--，+，-）
### 自增运算
假设 `ptr` 指针当前指向地址 1000。执行`ptr++`：
- 若ptr指向的数据类型为32位 int，  则 `ptr指向位置1004`
- 若ptr指向的数据为行为8 位 char，则`ptr指向位置为1001`

**即 ptr 每增加一次，它都将指向下一个数值的内存位置。** 我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，因为数组是一个常量指针，修改是非法的。

### 自减运算
同样地，对指针进行递减运算，即把值减去其数据类型的字节数。

### 比较运算
指针可以用关系运算符进行比较，如 ==、< 和 >。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。
指针比较的地址的大小。

## 指针 VS 数组
一个指向数组开头的指针，可以通过使用指针的算术运算或数组索引来访问数组。
指针可改变，数组名（即数组的首地址）是常量，不可改变。

## 指针数组
`int *ptr[3];` 将ptr声明为一个数组，数组中的每个元素都是指向一个int值的指针。
 以用一个指向字符的指针数组来存储一个字符串列表,如下：
 ```cpp?linenums
 const char *names[MAX] = {
                   "Zara Ali",
                   "Hina Ali",
                   "Nuha Ali",
                   "Sara Ali",
   };
```
## 指向指针的指针（多级间接寻址）
**定义：** `type **ptr;`
- 指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。
- 当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。访问目标值需加两个星号。

## 指针与函数
### 传递指针给函数
C++允许传递指针给函数，只需要简单地声明函数参数为指针类型即可。
`double getAverage(int *ar);` 传入参数为指向int型的指针

### 从函数返回指针
`int * myFunction(){}` 返回 int 型指针
注意: C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。

## C++指针 VS 引用
### 指针和引用的定义和性质联系与区别：
- 相同点： 都是地址的概念，指针指向一块内存，内容是所指内存的地址，引用时某块内存的别名。
- 定义：
  - 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元
  - 而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：
```cpp?linenums
int a=1;	int *p=&a;
int a=1;	int &b=a;
```
上面第一句定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。
上面第二句句定义了一个整形变量a和这个整形a的引用b，**事实上a和b是同一个东西，在内存占有同一个存储单元。**
- 性质区别:
	- 指针可以有多级，但是引用只能是一级（`int **p；合法` 而 `int &&a是不合法的`）
	- 引用使用时无需解引用（\*），指针需要解引用
	- 指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；
	- 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
	- `sizeof引用`得到的是所指向的变量(对象)的大小，而`sizeof指针`得到的是指针本身(所指向的对象的地址)的大小；
	- 指针和引用的自增(++)运算意义不一样（指针自增指向下一个值，引用自增导致数值增加）；
  	- 指针与引用作为函数参数传递的不同
```cpp?linenums
int a=10;
int b=10;
void swap1(int *a, int *b)   { /* **************** */ }
void swap2(int &a, int &b) { /* **************** */ }
swap1(&a, &b);		/* 指针传递 */
swap2(a,b );		/* 引用传递 */
```
-  引用的一些规则如下：
	- 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。
    - 不能有NULL 引用，引用必须与合法的存储单元关联（指针则可以是NULL）。
	- 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。
	
引用的主要功能是传递函数的参数和返回值。C++语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。

### 引用存在的意义
实际上“引用”可以做的任何事情“指针”也都能够做，那为什么还要“引用”？
 -  指针的概念完全是因为 c 语言的历史遗留，为了兼容 c 而设计的l。加入引用是为了支持operator overloading。这里有一个假设，如果没有引用，那么，用指针来operator overloading操作。`A operator +(const A *a, const A *_a);`那么使用的时候，&a + &b，这样看起来是不是很难受。而引入引用的概念，既可以满足overload operator，也不失重载value和pointer的灵活性。而且引用还带来一个指针无法替代的特性: 引用临时对象。因为引用必须在定义的时候就赋值，以后无法更改。 
- 同时，使用”引用“也是为用适当的工具做恰如其分的工作。指针能够毫无约束地操作内存中的如何东西，尽管指针功能强大，但是非常危险。就象一把刀，它可以用来砍树、裁纸、修指甲、理发等等，谁敢这样用？如果的确只需要借用一下某个对象的“别名”，那么就用“引用”，而不要用“指针”，以免发生意外。比如说，某人需要一份证明，本来在文件上盖上公章的印子就行了，如果把取公章的钥匙交给他，那么他就获得了不该有的权利。

在以下情况下你应该使用指针：
- 你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空）
- 是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。
    
在以下情况下应该使用引用：
   - 如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。
   - 当你重载某个操作符时，你应该使用引用
 
 尽可能使用引用，不得已时使用指针。当你不需要“重新指向”时，引用一般优先于指针被选用。这通常意味着引用用于类的公有接口时更有用。引用出现的典型场合是对象的表面，而指针用于对象内部。
 
##  智能指针
http://blog.csdn.net/xt_xiaotian/article/details/5714477